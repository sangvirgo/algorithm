package com.sang.theory2;

public class Main {

	public static void main(String[] args) {
		/*
		DiceRoller diceRoller= new DiceRoller();
		diceRoller.roll();
		
		//overloading constructors
		Pizza pizza1 =new Pizza("hihhihi", "shfja");
		System.out.println(pizza1.getBread()+ " " + pizza1.getSauce()+ " " + pizza1.getCheese());
		
		Pizza pizza2= new Pizza("fhsjdh", "sfh", "hasf");
		System.out.println(pizza2.getBread()+ " " + pizza2.getSauce()+ " " + pizza2.getCheese());
		
//		array of objects
		
		Car car = new Car("BMW");
		Garage garage= new Garage();
		
		garage.Park(car);
		garage.Park(new Car("Mercedes"));
		
		
		//static keyword
//		Trong ngôn ngữ lập trình Java, private static final int MAX_SPEED = 110; có ý nghĩa như sau:
//		private: Đây là từ khóa chỉ rằng biến MAX_SPEED chỉ có thể truy cập trong cùng một class. Nó không thể được truy cập từ bên ngoài class đó.
//		static: Từ khóa này biểu thị rằng biến MAX_SPEED thuộc về lớp (class) chứ không phải của các đối tượng (objects) được tạo từ lớp đó. Nó có nghĩa là chỉ có một bản sao của biến MAX_SPEED tồn tại cho mỗi lớp, không phụ thuộc vào số lượng đối tượng của lớp đó.
//		final: Từ khóa này chỉ rằng giá trị của biến MAX_SPEED không thể thay đổi sau khi đã được gán một giá trị. Một khi đã gán giá trị MAX_SPEED = 110;, thì không thể gán lại giá trị mới cho biến này.
//		int: Đây là kiểu dữ liệu của biến MAX_SPEED, có nghĩa là biến này là một số nguyên.
//		MAX_SPEED = 110;: Đây là giá trị được gán cho biến MAX_SPEED, có nghĩa là MAX_SPEED có giá trị là 110.
	
		//khi tạo method trong class, khi gọi lại chỉ cần: NameClass.Method();
		
		
		
//		4 THUỘC TÍNH QUAN TRỌNG TRONG OOP
		
		
//		1. Tính Đóng Gói (Encapsulation)
//		Định nghĩa: Tính đóng gói là quá trình ẩn giấu các dữ liệu và chi tiết thực hiện của một đối tượng, chỉ để lộ những gì cần thiết. Điều này giúp bảo vệ dữ liệu khỏi sự truy cập và thay đổi trực tiếp từ bên ngoài.
//
//		Cách thực hiện trong Java:
//
//		Sử dụng các từ khóa private, protected, và public để kiểm soát quyền truy cập vào các thành phần của lớp.
//		Sử dụng các phương thức getter và setter để truy cập và thay đổi giá trị của các thuộc tính.
//		
		
//		2. Tính Kế Thừa (Inheritance)
//		Định nghĩa: Tính kế thừa cho phép một lớp con (subclass) kế thừa các thuộc tính và phương thức của một lớp cha (superclass). Điều này giúp tái sử dụng mã và tạo ra một hệ thống phân cấp lớp.
//		Cách thực hiện trong Java:
//		Sử dụng từ khóa extends để chỉ định một lớp kế thừa từ một lớp khác.
		
		
//		3. Tính Đa Hình (Polymorphism)
//		Định nghĩa: Tính đa hình cho phép một đối tượng thể hiện nhiều hình thức khác nhau. Có hai loại đa hình: Đa hình lúc biên dịch (Compile-time Polymorphism) và Đa hình lúc thực thi (Run-time Polymorphism).
//		Compile-time Polymorphism (Method Overloading):
//		Nhiều phương thức cùng tên nhưng khác tham số trong cùng một lớp.
//		Ví dụ:
//		public class MathOperation {
//		    public int add(int a, int b) {
//		        return a + b;
//		    }
//
//		    public double add(double a, double b) {
//		        return a + b;
//		    }
//		}
//		Run-time Polymorphism (Method Overriding):
//		Ghi đè phương thức của lớp cha trong lớp con.
//		Ví dụ:
//
//		public class Animal {
//		    public void sound() {
//		        System.out.println("Animal makes a sound");
//		    }
//		}
//
//		public class Dog extends Animal {
//		    @Override
//		    public void sound() {
//		        System.out.println("Dog barks");
//		    }
//		}
//
//		public class Main {
//		    public static void main(String[] args) {
//		        Animal animal = new Dog();
//		        animal.sound(); // Gọi phương thức của lớp Dog
//		    }
//		}
		
//		4. Tính Trừu Tượng (Abstraction)
//		Định nghĩa: Tính trừu tượng là quá trình ẩn giấu các chi tiết thực hiện và chỉ hiển thị các chức năng của đối tượng. Điều này giúp giảm thiểu sự phức tạp và tập trung vào những gì đối tượng làm thay vì cách nó làm.
//
//		Cách thực hiện trong Java:
//
//		Sử dụng các lớp trừu tượng (abstract class) và giao diện (interface).
//		Ví dụ với abstract class:
//
//		java
//		Copy code
//		abstract class Animal {
//		    public abstract void sound();
//
//		    public void sleep() {
//		        System.out.println("This animal sleeps");
//		    }
//		}
//
//		public class Dog extends Animal {
//		    @Override
//		    public void sound() {
//		        System.out.println("Dog barks");
//		    }
//		}
//		Ví dụ với interface:
//
//		java
//		Copy code
//		interface Animal {
//		    void sound();
//		    void sleep();
//		}
//
//		public class Dog implements Animal {
//		    @Override
//		    public void sound() {
//		        System.out.println("Dog barks");
//		    }
//
//		    @Override
//		    public void sleep() {
//		        System.out.println("Dog sleeps");
//		    }
//		}
//		Tổng Kết
//		Tính đóng gói giúp bảo vệ dữ liệu và giảm sự phụ thuộc giữa các thành phần.
//		Tính kế thừa giúp tái sử dụng mã và tạo ra hệ thống phân cấp lớp.
//		Tính đa hình cho phép một đối tượng thể hiện nhiều hình thức khác nhau, giúp tăng tính linh hoạt của mã.
//		Tính trừu tượng giúp giảm sự phức tạp bằng cách ẩn giấu các chi tiết thực hiện và chỉ hiển thị các chức năng cần thiết.
				 */
		// inheritance
		
		Car car1=new 
		
	}

}
